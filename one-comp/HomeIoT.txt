#
# Default settings for the simulation
#

## Scenario settings
Scenario.name = homeIoT_scenario
Scenario.simulateConnections = true
Scenario.updateInterval = 0.1
# 43200s == 12h
Scenario.endTime = 10800


Scenario.simulateStorage = true


## Interface-specific settings:
# type : which interface class the interface belongs to
# For different types, the sub-parameters are interface-specific
# For DistanceCapacityInterface, the parameters are:
# transmitSpeed : transmit speed of the interface (bytes per second)
# transmitRange : range of the interface (meters)

# "Bluetooth" interface for all nodes
etherInterface.type = SimpleBroadcastInterface
# Transmit speed of 100 Mbps = 12.5MBps
etherInterface.transmitSpeed = 12.5M
etherInterface.transmitRange = 250

# Add different speed and range interfaces for the different types of nodes,
# and after "addInterface" (register the) into the ConnectivityGrid.

# Wlan interface for repos
wlanRepInterface.type = SimpleBroadcastInterface
wlanRepInterface.transmitSpeed =20M
wlanRepInterface.transmitRange = 600

# Wlan interface for pedestrins
wlanPedInterface.type = DistanceCapacityInterface
wlanPedInterface.transmitSpeeds = 18M, 15M, 12M, 9M, 6M, 3M
wlanPedInterface.transmitRange = 35
#dummy speed
wlanPedInterface.transmitSpeed =0

# Wlan interface for cars
# IEEE 1609 specifies: "Physical access for high-speed (<27 Mb/s ~ 3MB/s), short-range (<1000 m), and low
#latency wireless communications in the vehicular environment." THERE CAN BE A PHYSICAL LAYER PROBLEM HERE.
wlanCarInterface.type = DistanceCapacityInterface
wlanCarInterface.transmitSpeeds = 20M, 16M, 12M, 8M, 4M
wlanCarInterface.transmitRange = 100
#dummy speed
wlanCarInterface.transmitSpeed =0

# Wlan interface for busses
wlanBusInterface.type = DistanceCapacityInterface
wlanBusInterface.transmitSpeeds = 25M, 20M, 15M, 10M, 5M
wlanBusInterface.transmitRange = 200
#dummy speed
wlanBusInterface.transmitSpeed =0

# Define 4 different node groups
Scenario.nrofHostGroups = 6

## Group-specific settings:
# groupID : Group's identifier. Used as the prefix of host names
# nrofHosts: number of hosts in the group
# movementModel: movement model of the hosts (valid class name from movement package)
# waitTime: minimum and maximum wait times (seconds) after reaching destination
# speed: minimum and maximum speeds (m/s) when moving on a path
# bufferSize: size of the message buffer (bytes)
# router: router used to route messages (valid class name from routing package)
# activeTimes: Time intervals when the nodes in the group are active (start1, end1, start2, end2, ...)
# msgTtl : TTL (minutes) of the messages created by this host group, default=infinite

## Group and movement model specific settings
# pois: Points Of Interest indexes and probabilities (poiIndex1, poiProb1, poiIndex2, poiProb2, ... )
#       for ShortestPathMapBasedMovement
# okMaps : which map nodes are OK for the group (map file indexes), default=all
#          for all MapBasedMovent models
# routeFile: route's file path - for MapRouteMovement
# routeType: route's type - for MapRouteMovement


# Common settings for all groups
Group.movementModel = ShortestPathMapBasedMovement
Group.router = RepoDirectDeliveryRouter
Group.bufferSize = 100M
Group.waitTime = 0, 120
# All nodes have the bluetooth interface
Group.nrofInterfaces = 1
#Group.interface1 = wlanInterface
# Walking speeds
Group.speed = 0.5, 1.5
# Message TTL of 300 minutes (5 hours)
Group.msgTtl = 300

Group.nrofHosts = 40

# group1 (pedestrians) repositories specific settings
Group1.groupID = r
Group1.movementModel = RepoStationaryMovement
#Group1.speed = 0, 0
Group1.storageCapability = true
Group1.processingCapability = true
Group1.storageSize = 10G
Group1.compressionRate = 2
# The repositories have to have all 3 interfaces, to receive
# information from all 3 types of traffic.
Group1.nrofInterfaces = 2
Group1.interface1 = wlanCarInterface
Group1.interface2 = etherInterface
#Group1.interface3 = wlanBusInterface
#Group1.interface4 = wlanRepInterface
Group1.nrofHosts = 80

# group2 pedestrians specific settings
Group2.groupID = p
Group2.interface1 = wlanCarInterface
# # 10-50 km/h
# Group2.speed = 2.7, 13.9

# group3 cars specific settings
Group3.groupID = i
Group3.movementModel = OfficeIoTStationaryMovement
Group3.officeLocationsFile = data/HelsinkiMedium/A_homes.wkt
# Max distance from main office coordinate - needs tweaking.
Group3.officeSize = 150
Group3.nrOfOffices = 30
# Larger buffer size than pedestrians
Group3.bufferSize =100M
# More cars than anything else
Group3.nrofHosts = 250
Group3.interface1 = etherInterface

# group3 cars specific settings
Group4.groupID = i
Group4.movementModel = OfficeIoTStationaryMovement
Group4.officeLocationsFile = data/HelsinkiMedium/G_homes.wkt
# Max distance from main office coordinate - needs tweaking.
Group4.officeSize = 150
Group4.nrOfOffices = 30
# Larger buffer size than pedestrians
Group4.bufferSize = 300M
Group4.interface1 = wlanCarInterface
# More cars than anything else
Group4.nrofHosts = 250
Group4.interface1 = etherInterface

# The Bus groups
Group5.groupID = b
Group5.bufferSize = 500M
Group5.movementModel = MapRouteMovement
Group5.routeFile = data/tram3.wkt
Group5.routeType = 1
Group5.waitTime = 10, 30
Group5.speed = 4, 10
Group5.nrofHosts = 5
Group5.nrofInterfaces = 1
Group5.interface1 = wlanCarInterface

Group6.groupID = b
Group6.bufferSize = 500M
Group6.movementModel = MapRouteMovement
Group6.routeFile = data/tram4.wkt
Group6.routeType = 1
Group6.waitTime = 10, 30
Group6.speed = 4, 10
Group6.nrofHosts = 5
Group6.nrofInterfaces = 1
Group6.interface1 = wlanCarInterface

Group7.groupID = b
Group7.bufferSize = 500M
Group7.movementModel = MapRouteMovement
Group7.routeFile = data/tram10.wkt
Group7.routeType = 1
Group7.waitTime = 10, 30
Group7.speed = 4, 10
Group7.nrofHosts = 5
Group7.nrofInterfaces = 1
Group7.interface1 = wlanCarInterface

# Group5.groupID = t
# Group5.bufferSize = 50M
# Group5.movementModel = MapRouteMovement
# Group5.routeFile = data/tram4.wkt
# Group5.routeType = 2
# Group5.waitTime = 10, 30
# Group5.speed = 7, 10
# Group5.nrofHosts = 2

# Group6.groupID = t
# Group6.bufferSize = 50M
# Group6.movementModel = MapRouteMovement
# Group6.routeFile = data/tram10.wkt
# Group6.routeType = 2
# Group6.waitTime = 10, 30
# Group6.speed = 7, 10
# Group6.nrofHosts = 2


## Message creation parameters
# How many event generators
Events.nrof = 0
# Class of the pedestrians event generator
#Events1.class = ReposMessageEventGenerator
# (following settings are specific for the MessageEventGenerator class)
# Creation interval in seconds (one new message every 25 to 35 seconds)
#Events1.hostnames = p
#Events1.interval = 35,45
# Message sizes (900kB - 1MB)
#Events1.size = 900000,1100000
# range of message source addresses
#Events1.hosts = 40,79
# range of message destination addresses
#Events1.tohosts = r
# Message ID prefix
#Events1.prefix = MP

# Class of the cars event generator
#Events2.class = ReposMessageEventGenerator
# (following settings are specific for the MessageEventGenerator class)
# Creation interval in seconds (one new message every 25 to 35 seconds)
#Events2.interval = 4,5
# Message sizes (900kB - 1MB)
#Events2.size = 900000,1100000
# range of message source/destination addresses
#Events2.hosts = 80,119
# range of message destination addresses
#Events2.tohosts = r
# Message ID prefix
#Events2.prefix = MC

# Class of the busses event generator
#Events3.class = ReposMessageEventGenerator
# (following settings are specific for the MessageEventGenerator class)
# Creation interval in seconds (one new message every 25 to 35 seconds)
#Events3.interval = 1,2
# Message sizes (900kB - 1MB)
#Events3.size = 900000,1100000
# range of message source/destination addresses
#Events3.hosts = 120,134
# range of message destination addresses
#Events3.tohosts = r
# Message ID prefix
#Events3.prefix = MB

# Class of storage depletion
#Events4.class = ReposStorageConstantDepletion
# (following settings are specific for the ReposStorageConstantDepletion class)
# Depletion interval in seconds (a number of messages depleted/second)
#Events4.depletionInterval = [3; 2; 1]
# Number of message depleted each depletionInterval
#Events4.msgNo = 2
# Host names of host storages to be depleted
#Events4.depletionHostnames = r
# Lower limit at which depletion starts
#Events4.lowerLimit = 2500000000

# Class of storage depletion
#Events4.class = ReposStorageConstantProcDepletion
# (following settings are specific for the ReposStorageConstantDepletion class)
# Depletion interval in seconds (a number of messages depleted/second)
#Events4.depletionInterval = 1
# Number of message depleted each depletionInterval
#Events4.processedMsgNo = [3; 2; 1]
# Host names of host storages to be depleted
#Events4.procDepletionHostnames = r


## Movement model settings
# seed for movement models' pseudo random number generator (default = 0)
MovementModel.rngSeed = 1
# World's size for Movement Models without implicit size (width, height; meters)
MovementModel.worldSize = 4500, 3400
# How long time to move hosts in the world before real simulation
MovementModel.warmup = 1000

## Map based movement -movement model specific settings
MapBasedMovement.nrofMapFiles = 4

MapBasedMovement.mapFile1 = data/roads.wkt
MapBasedMovement.mapFile2 = data/main_roads.wkt
MapBasedMovement.mapFile3 = data/pedestrian_paths.wkt
MapBasedMovement.mapFile4 = data/shops.wkt

## Reports - all report names have to be valid report classes

# how many reports to load
Report.nrofReports = 15
# length of the warm up period (simulated seconds)
Report.warmup = 0
RepoMessageLocationReport.granularity = 1
RepoStoredMessageLocationReport.granularity = 1
MobileMessageLocationReport.granularity = 1
RepoIncomingSpeedsReport.granularity = 1
RepoDeletedMessagesReport.granularity = 1
RepoProcessingMessageLocationReport.granularity = 1
RepoProcessedMessageLocationReport.granularity = 1
RepoAllMessagesLocationReport.granularity = 1
MobileDeletedMessagesReport.granularity = 1
RepoUnprocessedMessagesLocationReport.granularity = 1
RepoDepletedProcBWReport.granularity = 1
RepoDepletedUnProcBWReport.granularity = 1
RepoDepletedStorageBWReport.granularity = 1
RepoDepletedCloudStorageBWReport.granularity = 1
Report.endTime = 10750
FileLocationReport.granularity = 5

# default directory of reports (can be overridden per Report with output setting)
Report.reportDir = reports/
# Report classes to load
Report.report1 = RepoIncomingSpeedsReport
Report.report2 = MobileDeletedMessagesReport

Report.report3 = RepoProcessingMessageLocationReport
Report.report4 = RepoStoredMessageLocationReport

Report.report5 = RepoProcessedMessageLocationReport
Report.report6 = RepoAllMessagesLocationReport
Report.report7 = RepoDepletedProcBWReport
Report.report8 = RepoDepletedUnProcBWReport
Report.report9 = RepoDepletedStorageBWReport
Report.report10 = RepoDepletedCloudStorageBWReport
Report.report11 = RepoSatisfactionReport
Report.report12 = RepoStorTimesReport
Report.report13 = RepoProcFreshnessReport
Report.report14 = RepoUnProcessedReport
Report.report15 = RepoOvertimeReport

RepoIncomingSpeedsReport.output = [HomeIoT/RISR1;HomeIoT/RISR2;HomeIoT/RISR3; HomeIoT/RISR4; HomeIoT/RISR5; HomeIoT/RISR6]
RepoDeletedMessagesReport.output = [HomeIoT/RDMR1;HomeIoT/RDMR2;HomeIoT/RDMR3; reports/RDMR4; HomeIoT/RDMR5; HomeIoT/RDMR6]
MobileDeletedMessagesReport.output = [HomeIoT/MDMR1;HomeIoT/MDMR2;HomeIoT/MDMR3; HomeIoT/MDMR4; HomeIoT/MDMR5; HomeIoT/MDMR6]
RepoProcessingMessageLocationReport.output = [HomeIoT/RPrMR1;HomeIoT/RPrMR2;HomeIoT/RPrMR3; HomeIoT/RPrMR4; HomeIoT/RPrMR5; HomeIoT/RPrMR6]
RepoStoredMessageLocationReport.output = [HomeIoT/RSMR1;HomeIoT/RSMR2;HomeIoT/RSMR3; HomeIoT/RSMR4; HomeIoT/RSMR5; HomeIoT/RSMR6]
RepoProcessedMessageLocationReport.output = [HomeIoT/RPMR1;HomeIoT/RPMR2;HomeIoT/RPMR3; HomeIoT/RPMR4; HomeIoT/RPMR5; HomeIoT/RPMR6]
RepoAllMessagesLocationReport.output = [HomeIoT/RAMR1;HomeIoT/RAMR2;HomeIoT/RAMR3; HomeIoT/RAMR4; HomeIoT/RAMR5; HomeIoT/RAMR6]
RepoDepletedProcBWReport.output = [HomeIoT/RPBWR1;HomeIoT/RPBWR2;HomeIoT/RPBWR3; HomeIoT/RPBWR4; HomeIoT/RPBWR5; HomeIoT/RPBWR6]
RepoDepletedUnProcBWReport.output = [HomeIoT/RUPBWR1;HomeIoT/RUPBWR2;HomeIoT/RUPBWR3; HomeIoT/RUPBWR4; HomeIoT/RUPBWR5; HomeIoT/RUPBWR6]
RepoDepletedCloudStorageBWReport.output = [HomeIoT/RCSBWR1; HomeIoT/RCSBWR2; HomeIoT/RCSBWR3; HomeIoT/RCSBWR4; HomeIoT/RCSBWR5; HomeIoT/RCSBWR6]
RepoDepletedStorageBWReport.output = [HomeIoT/RSBWR1; HomeIoT/RSBWR2; HomeIoT/RSBWR3; HomeIoT/RSBWR4; HomeIoT/RSBWR5; HomeIoT/RSBWR6]
RepoSatisfactionReport.output = [HomeIoT/RSR1; HomeIoT/RSR2; HomeIoT/RSR3; HomeIoT/RSR4; HomeIoT/RSR5; HomeIoT/RSR6]
RepoProcFreshnessReport.output = [HomeIoT/RPFR1; HomeIoT/RPFR2; HomeIoT/RPFR3; HomeIoT/RPFR4; HomeIoT/RPFR5; HomeIoT/RPFR6]
RepoStorTimesReport.output = [HomeIoT/RSTR1; HomeIoT/RSTR2; HomeIoT/RSTR3; HomeIoT/RSTR4; HomeIoT/RSTR5; HomeIoT/RSTR6]
RepoUnProcessedReport.output = [HomeIoT/RUR1; HomeIoT/RUR2; HomeIoT/RUR3; HomeIoT/RUR4; HomeIoT/RUR5; HomeIoT/RUR6]
RepoOvertimeReport.output = [HomeIoT/ROR1; HomeIoT/ROR2; HomeIoT/ROR3; HomeIoT/ROR4; HomeIoT/ROR5; HomeIoT/ROR6]

## Default settings for some routers settings
ProphetRouter.secondsInTimeUnit = 30
SprayAndWaitRouter.nrofCopies = 6
SprayAndWaitRouter.binaryMode = true

## Optimization settings -- these affect the speed of the simulation
## see World class for details.
Optimization.cellSizeMult = 5
Optimization.randomizeUpdateOrder = true


## GUI settings

# GUI underlay image settings
GUI.UnderlayImage.fileName = data/helsinki_underlay.png
# Image offset in pixels (x, y)
GUI.UnderlayImage.offset = 64, 20
# Scaling factor for the image
GUI.UnderlayImage.scale = 4.75
# Image rotation (radians)
GUI.UnderlayImage.rotate = -0.015

# how many events to show in the log panel (default = 30)
GUI.EventLogPanel.nrofEvents = 100
# Regular Expression log filter (see Pattern-class from the Java API for RE-matching details)
#GUI.EventLogPanel.REfilter = .*p[1-9]<->p[1-9]$


# Define new application
procApp.type = ProcApplication
# Messages to be depleted (processing first and, if any left, nonprocessing, after)
procApp.depletionRate = 20M
procApp.cloudRate = 10M
procApp.passive = false
procApp.coreNo = 10
procApp.maxStorage = 0.95
procApp.minStorage = 0.001
#procApp.storageMode = true

# Define new application
procApp1.type = ProcGenApplication
procApp1.interval = 2
procApp1.delay = 0.5
procApp1.nonprocShelf = 3
procApp1.destinationName = r
procApp1.procSize = 1M
# Stored message ratio to processing message (no. of messages to be stored vs. no. of messages to be processed)
procApp1.compressRate = 1,0
procApp1.passiveRate = 1,0
procApp1.passive = false

# Define new application
procApp2.type = ProcGenApplication
procApp2.interval = 1
procApp2.delay = 0.1
procApp2.freshPer = 1
procApp2.procShelf = 2
procApp2.nonprocShelf = [50; 200; 500; 800; 1000]
procApp2.destinationName = r
procApp2.procSize = 50k
# Stored message ratio to processing message (no. of messages to be stored vs. no. of messages to be processed)
procApp2.compressRate = 1,3
procApp2.passiveRate = [3,1; 5,2; 4,2; 2,2; 1,2]]
procApp2.passive = false

# Define new application
procApp3.type = ProcGenApplication
procApp3.interval = 1
procApp3.delay = 0.3
procApp3.freshPer = 1.5
procApp3.procShelf = 2
procApp3.nonprocShelf = 1.5
procApp3.destinationName = r
procApp3.procSize = 1M
# Stored message ratio to processing message (no. of messages to be stored vs. no. of messages to be processed)
procApp3.compressRate = 1,3
procApp3.passiveRate = 2,2
procApp3.passive = false

# Set proc app for all nodes
Group1.nrofApplications = 1
Group2.nrofApplications = 1
Group3.nrofApplications = 1
Group4.nrofApplications = 1
Group5.nrofApplications = 1
Group6.nrofApplications = 1
Group7.nrofApplications = 1
Group1.application1 = procApp
Group2.application1 = procApp1
Group3.application1 = procApp2
Group4.application1 = procApp2
Group5.application1 = procApp3
Group6.application1 = procApp3
Group7.application1 = procApp3


